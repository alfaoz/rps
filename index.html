<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>rps</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Comic Neue', 'Comic Sans MS', 'Comic Sans', cursive;
      background: black;
      color: white;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 10px;
    }

    .container {
      max-width: 500px;
      width: 100%;
      text-align: center;
    }

    h1 {
      font-size: 1.5em;
      margin-bottom: 15px;
      font-weight: normal;
    }

    .screen {
      display: none;
    }

    .screen.active {
      display: block;
    }

    button {
      font-family: 'Comic Neue', 'Comic Sans MS', 'Comic Sans', cursive;
      background: white;
      color: black;
      border: 2px solid white;
      padding: 10px 20px;
      font-size: 1em;
      cursor: pointer;
      margin: 5px 5px;
    }

    button.waiting-opponent {
      background: black;
      color: white;
      animation: blink 1s ease-in-out infinite;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    button:hover {
      background: black;
      color: white;
    }

    button:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .choice-btn {
      font-size: 3em;
      width: 80px;
      height: 80px;
      padding: 0;
      margin: 5px;
      background: black;
      color: white;
      border: 2px solid white;
    }

    .choice-btn:hover:not(:disabled) {
      background: white;
      color: black;
    }

    .choice-btn.selected {
      background: white;
      color: black;
    }

    input {
      font-family: 'Comic Neue', 'Comic Sans MS', 'Comic Sans', cursive;
      background: black;
      border: 2px solid white;
      color: white;
      padding: 10px;
      font-size: 1em;
      text-align: center;
      width: 150px;
      margin: 10px;
    }

    input:focus {
      outline: none;
      border-color: white;
    }

    .share-link {
      border: 2px solid white;
      padding: 15px;
      margin: 20px 0;
      cursor: pointer;
    }

    .share-link:hover {
      background: white;
      color: black;
    }

    .status {
      font-size: 1.2em;
      margin: 10px 0;
      min-height: 30px;
    }

    .result {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: black;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      padding: 40px 20px 20px;
    }

    .battle-emoji {
      font-size: 5em;
      margin: 10px 0;
      opacity: 0.7;
      transition: all 0.3s ease;
    }

    .battle-emoji.winner {
      opacity: 1;
      text-shadow: 0 0 20px white;
    }

    .battle-label {
      font-size: 0.9em;
      opacity: 0.6;
      margin-top: -10px;
    }

    .battle-outcome {
      font-size: 2.5em;
      margin: 20px 0;
      font-weight: bold;
    }

    .battle-score {
      font-size: 1em;
      opacity: 0.7;
      margin-top: 10px;
    }

    .win-streak {
      font-size: 1.2em;
      margin-top: 5px;
      color: white;
      font-weight: bold;
    }

    .win-streak.active {
      animation: pulse 1s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.05); }
    }

    .battle-combo {
      font-size: 1.5em;
      margin: 10px 0 5px 0;
      color: white;
      font-weight: bold;
      animation: comboAppear 0.3s ease-out;
    }

    @keyframes comboAppear {
      0% {
        opacity: 0;
        transform: scale(0.8);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
    }

    .choice-btn.selected {
      background: white;
      color: black;
    }

    #playAgainBtn {
      position: relative;
      margin: 30px auto 20px auto;
      display: block;
      z-index: 1001;
    }

    .reaction-btn {
      font-size: 1.3em;
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      padding: 0 8px;
    }

    .reaction-btn:hover {
      opacity: 1;
      transform: scale(1.2);
    }

    .reaction-separator {
      opacity: 0.3;
      margin: 0 2px;
    }

    .reaction-display {
      position: fixed;
      font-size: 4em;
      z-index: 2000;
      animation: reactionPop 1.5s ease-out forwards;
      pointer-events: none;
    }

    @keyframes reactionPop {
      0% {
        opacity: 0;
        transform: scale(0.5) translateY(0);
      }
      20% {
        opacity: 1;
        transform: scale(1.2) translateY(-20px);
      }
      100% {
        opacity: 0;
        transform: scale(1) translateY(-120px);
      }
    }

    .error {
      margin: 20px 0;
      padding: 15px;
      border: 2px solid white;
    }

    .timer {
      font-size: 2em;
      margin: 5px 0;
      font-weight: bold;
    }

    .timer.shake {
      animation: shake 0.8s ease-in-out infinite;
    }

    .timer.selected {
      opacity: 0.3;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-2px); }
      75% { transform: translateX(2px); }
    }

    small {
      font-size: 0.8em;
      opacity: 0.7;
    }

    .debug-info {
      font-size: 0.7em;
      margin: 5px 0;
      opacity: 0.5;
    }

    .score {
      font-size: 0.9em;
      margin: 10px 0;
      cursor: pointer;
      opacity: 0.7;
    }

    .score:hover {
      opacity: 1;
    }

    .score.pending-reset, .score.reset-incoming {
      animation: blink 1s ease-in-out infinite;
    }

    @keyframes fadeIn {
      0% {
        opacity: 0;
      }
      100% {
        opacity: 1;
      }
    }

    .leave-btn {
      position: fixed;
      top: 10px;
      left: 10px;
      background: none;
      border: none;
      color: #555;
      font-size: 0.9em;
      cursor: pointer;
      padding: 5px 10px;
      z-index: 1500;
    }

    .leave-btn:hover {
      color: #888;
      background: none;
    }

    .leave-confirm {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      z-index: 2000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 20px;
    }

    .leave-confirm-text {
      font-size: 1.2em;
    }

    .leave-confirm-buttons {
      display: flex;
      gap: 15px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>rock paper scissors!</h1>

    <!-- Menu Screen -->
    <div id="menu" class="screen active">
      <button onclick="createRoom()">create game</button>
      <br>
      <input type="text" id="roomInput" placeholder="room code" maxlength="5">
      <br>
      <button onclick="joinRoom()">join game</button>
      <div id="menuError" class="error" style="display: none;"></div>
    </div>

    <!-- Waiting Screen -->
    <div id="waiting" class="screen">
      <div class="status">room code:</div>
      <div class="share-link" id="shareLink" onclick="copyLink()">
        <div id="roomCode"></div>
        <small>click to copy link :3</small>
      </div>
      <div class="status">waiting for friend...</div>
    </div>

    <!-- Game Screen -->
    <div id="game" class="screen">
      <button class="leave-btn" onclick="showLeaveConfirm()">leave</button>
      <div id="debugInfo" class="debug-info" style="display: none;">ping: <span id="myPing">0</span>ms</div>
      <div class="score" id="score" onclick="toggleResetScore()">you: 0 | them: 0</div>
      <div class="win-streak" id="winStreak" style="display: none;"></div>
      <div class="timer" id="timer">3</div>
      <div class="status" id="gameStatus">pick one!</div>
      <div>
        <button class="choice-btn" onclick="selectChoice('rock')">‚úä</button>
        <button class="choice-btn" onclick="selectChoice('paper')">‚úã</button>
        <button class="choice-btn" onclick="selectChoice('scissors')">‚úåÔ∏è</button>
      </div>
      <div id="result" class="result" style="display: none;"></div>
    </div>

    <!-- Leave Confirmation Dialog -->
    <div id="leaveConfirm" class="leave-confirm" style="display: none;">
      <div class="leave-confirm-text">leave the game?</div>
      <div class="leave-confirm-buttons">
        <button onclick="confirmLeave()">yes</button>
        <button onclick="hideLeaveConfirm()">no</button>
      </div>
    </div>

    <!-- Player Left Dialog -->
    <div id="playerLeftDialog" class="leave-confirm" style="display: none;">
      <div class="leave-confirm-text">opponent left the game :(</div>
      <div class="leave-confirm-buttons">
        <button onclick="exitToMenu()">okay</button>
      </div>
    </div>
  </div>

  <script>
    // Detect base path from current URL or default to empty
    const BASE_PATH = window.location.pathname.startsWith('/beta') ? '/beta' : '';
  </script>
  <script>
    // Dynamic socket.io script loading
    const socketScript = document.createElement('script');
    socketScript.src = `${BASE_PATH}/socket.io/socket.io.js`;
    document.head.appendChild(socketScript);
  </script>
  <script>
    let sessionId = null;
    let socket = null;
    let currentRoom = null;
    let myChoice = null;
    let timerInterval = null;
    let timeLeft = 3;
    let myScore = 0;
    let theirScore = 0;
    let winStreak = 0;
    let myPlayerIndex = null;
    let debugMode = false;
    let myPing = 0;
    let pingInterval = null;
    let roundStartTime = null;
    let timerDuration = 3;
    let closeCall = false;

    const choiceEmoji = { rock: '‚úä', paper: '‚úã', scissors: '‚úåÔ∏è' };

    // Initialize session and socket connection
    async function initializeSession() {
      // Wait for socket.io to load
      while (typeof io === 'undefined') {
        await new Promise(r => setTimeout(r, 50));
      }

      try {
        const response = await fetch(`${BASE_PATH}/api/session`, { credentials: 'include' });
        const data = await response.json();
        sessionId = data.sessionId;
        console.log('Session ID:', sessionId);

        socket = io({ path: `${BASE_PATH}/socket.io` });

        return new Promise((resolve) => {
          socket.on('connect', () => {
            console.log('Socket connected:', socket.id);
            setupSocketListeners();
            socket.emit('register_session', sessionId);
            resolve();
          });
        });
      } catch (error) {
        console.error('Failed to initialize session:', error);
      }
    }

    // Call initialization on page load
    initializeSession().then(() => {
      const urlParams = new URLSearchParams(window.location.search);
      const roomCode = urlParams.get('room');
      if (roomCode) {
        document.getElementById('roomInput').value = roomCode;
        // Wait a bit for reconnection to potentially happen first
        setTimeout(() => {
          if (!currentRoom) {
            console.log('[CLIENT] Auto-joining from URL:', roomCode);
            if (roomCode.toLowerCase() === 'kiraz') {
              setTimeout(() => joinRoom(), 100);
            } else {
              joinRoom();
            }
          } else {
            console.log('[CLIENT] Already in room', currentRoom, '- skipping auto-join');
          }
        }, 300);
      }
    });

    const screens = {
      menu: document.getElementById('menu'),
      waiting: document.getElementById('waiting'),
      game: document.getElementById('game')
    };

    function showScreen(screenName) {
      Object.values(screens).forEach(screen => screen.classList.remove('active'));
      screens[screenName].classList.add('active');
    }

    // Detect duplicate tabs using BroadcastChannel
    const tabChannel = new BroadcastChannel('rps_tab_sync');
    const tabId = Math.random().toString(36).slice(2);
    let isActiveTab = true;

    // Announce this tab and listen for others
    tabChannel.onmessage = (event) => {
      if (event.data.type === 'tab_opened' && event.data.tabId !== tabId) {
        // Another tab opened - warn them if we're in a game
        if (currentRoom) {
          tabChannel.postMessage({ type: 'game_active', tabId, roomId: currentRoom });
        }
      } else if (event.data.type === 'game_active' && event.data.tabId !== tabId) {
        // Another tab has an active game
        isActiveTab = false;
        showError('game open in another tab!');
        if (socket) {
          socket.disconnect();
        }
      } else if (event.data.type === 'tab_closed' && event.data.tabId !== tabId) {
        // Other tab closed, we can be active again
        isActiveTab = true;
      }
    };

    // Announce ourselves
    tabChannel.postMessage({ type: 'tab_opened', tabId });

    // Cleanup on close
    window.addEventListener('beforeunload', () => {
      tabChannel.postMessage({ type: 'tab_closed', tabId });
    });

    // Handle tab visibility - resync timer when becoming visible
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible' && currentRoom && isActiveTab) {
        if (roundStartTime && timerInterval) {
          calculateTimeLeft();
          updateTimerDisplay();

          if (timeLeft <= 0 && !myChoice) {
            const choices = ['rock', 'paper', 'scissors'];
            const randomChoice = choices[Math.floor(Math.random() * choices.length)];
            makeChoice(randomChoice, true);
          }
        }
      }
    });

    function createRoom() {
      if (!socket) {
        showError('connecting... please wait');
        return;
      }
      if (!isActiveTab) {
        showError('game open in another tab!');
        return;
      }
      socket.emit('create_room');
    }

    function joinRoom() {
      if (!socket) {
        showError('connecting... please wait');
        return;
      }
      if (!isActiveTab) {
        showError('game open in another tab!');
        return;
      }

      const roomId = document.getElementById('roomInput').value.trim();
      if (!roomId) {
        showError('please enter a room code >:c');
        return;
      }

      // easter eggs :3
      if (roomId.toLowerCase() === 'kiraz') {
        showLoveMessage('i love you!!!! - alfa');
        return;
      }

      if (roomId.toLowerCase() === 'debug') {
        debugMode = true;
        document.getElementById('debugInfo').style.display = 'block';
        showError('debug mode enabled :3');
        document.getElementById('roomInput').value = '';
        startPingMeasurement();
        return;
      }

      socket.emit('join_room', roomId.toUpperCase());
    }

    function startTimer(duration = 3, serverTime = null) {
      timerDuration = duration;
      roundStartTime = serverTime || Date.now();

      if (timerInterval) clearInterval(timerInterval);

      calculateTimeLeft();
      updateTimerDisplay();

      timerInterval = setInterval(() => {
        calculateTimeLeft();
        updateTimerDisplay();

        if (timeLeft <= 0) {
          clearInterval(timerInterval);
          if (!myChoice) {
            const choices = ['rock', 'paper', 'scissors'];
            const randomChoice = choices[Math.floor(Math.random() * choices.length)];
            makeChoice(randomChoice, true);
          }
        }
      }, 100);
    }

    function calculateTimeLeft() {
      const elapsed = (Date.now() - roundStartTime) / 1000;
      timeLeft = Math.max(0, timerDuration - elapsed);
    }

    function updateTimerDisplay() {
      const timerElement = document.getElementById('timer');
      timerElement.textContent = timeLeft.toFixed(1);

      if (timeLeft <= 1.5 && timeLeft > 0) {
        timerElement.classList.add('shake');
      } else {
        timerElement.classList.remove('shake');
      }
    }

    function selectChoice(choice) {
      if (myChoice) return;
      makeChoice(choice, false);
    }

    function makeChoice(choice, auto = false) {
      if (myChoice) return;
      if (!socket) return;

      myChoice = choice;

      // Track if I made it with 0.3 or less seconds remaining lmao
      if (timeLeft <= 0.3 && timeLeft > 0) {
        closeCall = true;
      }

      socket.emit('make_choice', { roomId: currentRoom, choice });

      document.getElementById('timer').classList.add('selected');

      document.querySelectorAll('.choice-btn').forEach(btn => {
        btn.classList.remove('selected');
        btn.disabled = true;
      });

      const buttons = document.querySelectorAll('.choice-btn');
      const choiceMap = { rock: 0, paper: 1, scissors: 2 };
      buttons[choiceMap[choice]].classList.add('selected');

      if (auto) {
        document.getElementById('gameStatus').textContent = "time up! auto-picked :O";
      } else {
        document.getElementById('gameStatus').textContent = 'waiting for friend...';
      }
    }

    function playAgain() {
      if (!socket) return;

      const btn = document.getElementById('playAgainBtn');
      btn.classList.add('waiting-opponent');
      btn.textContent = 'waiting for friend...';
      btn.disabled = true;

      socket.emit('ready_for_next', { roomId: currentRoom });
    }

    function copyLink() {
      const url = window.location.href.split('?')[0] + '?room=' + currentRoom;

      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(url).then(() => {
          showCopiedMessage();
        }).catch(() => {
          fallbackCopy(url);
        });
      } else {
        fallbackCopy(url);
      }
    }

    function fallbackCopy(text) {
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.left = '-999999px';
      document.body.appendChild(textArea);
      textArea.select();

      try {
        document.execCommand('copy');
        showCopiedMessage();
      } catch (err) {
        showCopiedMessage('room code: ' + currentRoom);
      }

      document.body.removeChild(textArea);
    }

    function showCopiedMessage(message = 'copied! :3') {
      const linkDiv = document.getElementById('shareLink');
      const code = currentRoom;
      linkDiv.innerHTML = `<div>${message}</div>`;
      setTimeout(() => {
        linkDiv.innerHTML = `<div id="roomCode">${code}</div><small>click to copy link :3</small>`;
      }, 1500);
    }

    function showError(message) {
      const errorDiv = document.getElementById('menuError');
      errorDiv.textContent = message;
      errorDiv.style.display = 'block';
      setTimeout(() => {
        errorDiv.style.display = 'none';
      }, 3000);
    }

    function showLoveMessage(message) {
      const titleElement = document.querySelector('h1');
      const originalTitle = titleElement.textContent;

      titleElement.textContent = 'i love you!!!!';
      titleElement.style.animation = 'fadeIn 0.5s ease-in-out';

      setTimeout(() => {
        titleElement.textContent = originalTitle;
        titleElement.style.animation = 'fadeIn 0.5s ease-in-out';
      }, 2000);
    }

    function updateScore() {
      document.getElementById('score').textContent = `you: ${myScore} | them: ${theirScore}`;
    }

    function updateStreak() {
      const streakDiv = document.getElementById('winStreak');
      if (winStreak >= 2) {
        streakDiv.textContent = `combo x${winStreak}`;
        streakDiv.style.display = 'block';
        streakDiv.classList.add('active');
      } else {
        streakDiv.style.display = 'none';
        streakDiv.classList.remove('active');
      }
    }

    function getReactionsHTML() {
      return `
        <button onclick="playAgain()" id="playAgainBtn">play again? :p</button>
        <div style="margin-top: 20px; opacity: 0.4;">
          <button class="reaction-btn" onclick="sendReaction('‚ù§Ô∏è')">‚ù§Ô∏è</button><span class="reaction-separator">|</span><button class="reaction-btn" onclick="sendReaction('üî•')">üî•</button><span class="reaction-separator">|</span><button class="reaction-btn" onclick="sendReaction('üò≠')">üò≠</button><span class="reaction-separator">|</span><button class="reaction-btn" onclick="sendReaction('üòî')">üòî</button><span class="reaction-separator">|</span><button class="reaction-btn" onclick="sendReaction('üòµ‚Äçüí´')">üòµ‚Äçüí´</button>
        </div>
      `;
    }

    function renderResult(myChoiceVal, theirChoiceVal, result, currentMyScore, currentTheirScore, currentWinStreak) {
      const myEmoji = choiceEmoji[myChoiceVal];
      const theirEmoji = choiceEmoji[theirChoiceVal];

      let outcomeText = '';
      let myWinner = false;
      let theirWinner = false;

      if (result === 'win') {
        outcomeText = 'you win!!';
        myWinner = true;
      } else if (result === 'lose') {
        outcomeText = "you lose :'(";
        theirWinner = true;
      } else {
        outcomeText = 'tie! :O';
      }

      const comboHTML = result === 'win' && currentWinStreak >= 2 ? `<div class="battle-combo">combo x${currentWinStreak}</div>` : '';
      const closeCallHTML = closeCall ? `<div class="battle-combo">close call!</div>` : '';

      return `
        <div class="battle-emoji${theirWinner ? ' winner' : ''}">${theirEmoji}</div>
        <div class="battle-label">them</div>
        <div style="margin: 20px 0;"></div>
        <div class="battle-emoji${myWinner ? ' winner' : ''}">${myEmoji}</div>
        <div class="battle-label">you</div>
        <div class="battle-outcome" style="margin-top: 20px;">${outcomeText}</div>
        ${comboHTML}
        ${closeCallHTML}
        <div class="battle-score">you: ${currentMyScore} | them: ${currentTheirScore}</div>
        ${getReactionsHTML()}
      `;
    }

    function sendReaction(emoji) {
      if (!currentRoom || !socket) return;

      socket.emit('send_reaction', { roomId: currentRoom, emoji });
      displayReaction(emoji);
    }

    function displayReaction(emoji) {
      const reactionDiv = document.createElement('div');
      reactionDiv.className = 'reaction-display';
      reactionDiv.textContent = emoji;

      const randomX = 30 + Math.random() * 40;
      const randomY = 35 + Math.random() * 30;

      reactionDiv.style.left = randomX + '%';
      reactionDiv.style.top = randomY + '%';

      document.body.appendChild(reactionDiv);

      setTimeout(() => {
        if (reactionDiv.parentNode) {
          document.body.removeChild(reactionDiv);
        }
      }, 1500);
    }

    function startPingMeasurement() {
      if (pingInterval) clearInterval(pingInterval);
      if (!socket) return;

      pingInterval = setInterval(() => {
        if (!socket) return;
        const start = Date.now();
        socket.emit('ping_request', { timestamp: start });
      }, 1000);
    }

    function toggleResetScore() {
      if (!socket) return;

      const scoreDiv = document.getElementById('score');
      const hasPending = scoreDiv.classList.contains('pending-reset');
      const hasIncoming = scoreDiv.classList.contains('reset-incoming');

      if (hasIncoming) {
        scoreDiv.classList.remove('reset-incoming');
        scoreDiv.classList.add('pending-reset');
        scoreDiv.textContent = 'resetting...';
        socket.emit('request_reset', { roomId: currentRoom });
      } else if (hasPending) {
        scoreDiv.classList.remove('pending-reset');
        updateScore();
        socket.emit('cancel_reset', { roomId: currentRoom });
      } else {
        scoreDiv.classList.add('pending-reset');
        scoreDiv.textContent = 'waiting for friend...';
        socket.emit('request_reset', { roomId: currentRoom });
      }
    }

    function showLeaveConfirm() {
      document.getElementById('leaveConfirm').style.display = 'flex';
    }

    function hideLeaveConfirm() {
      document.getElementById('leaveConfirm').style.display = 'none';
    }

    function confirmLeave() {
      if (!socket || !currentRoom) return;

      socket.emit('leave_game');
      exitToMenu();
    }

    function exitToMenu() {
      // Clear room state
      currentRoom = null;
      myScore = 0;
      theirScore = 0;
      winStreak = 0;
      myChoice = null;
      if (timerInterval) clearInterval(timerInterval);

      // Hide dialogs
      document.getElementById('leaveConfirm').style.display = 'none';
      document.getElementById('playerLeftDialog').style.display = 'none';
      document.getElementById('result').style.display = 'none';

      // Clean URL
      window.history.pushState({}, '', window.location.pathname);

      // Reset UI and show menu
      updateScore();
      showScreen('menu');
    }

    function showPlayerLeftDialog() {
      document.getElementById('playerLeftDialog').style.display = 'flex';
    }

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && currentRoom) {
        const leaveConfirm = document.getElementById('leaveConfirm');
        if (leaveConfirm.style.display === 'flex') {
          hideLeaveConfirm();
        } else {
          showLeaveConfirm();
        }
      }
    });

    function resetGameUI() {
      myChoice = null;
      closeCall = false;
      // Clear any existing timer
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      document.getElementById('result').style.display = 'none';
      document.getElementById('timer').classList.remove('selected');
      document.getElementById('timer').classList.remove('shake');
      document.querySelectorAll('.choice-btn').forEach(btn => {
        btn.classList.remove('selected');
        btn.disabled = false;
      });
    }

    // Setup all socket event listeners
    function setupSocketListeners() {
      socket.on('session_registered', () => {
        console.log('[CLIENT] Session registered');
      });

      socket.on('room_created', (roomId) => {
        currentRoom = roomId;
        myPlayerIndex = 1;
        document.getElementById('roomCode').textContent = roomId;
        const newUrl = window.location.pathname + '?room=' + roomId;
        window.history.pushState({}, '', newUrl);
        showScreen('waiting');
      });

      socket.on('room_joined', ({ roomId, playerIndex }) => {
        console.log('[CLIENT] Joined room:', roomId, 'as player', playerIndex);
        currentRoom = roomId;
        myPlayerIndex = playerIndex;

        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('room') !== roomId) {
          const newUrl = window.location.pathname + '?room=' + roomId;
          window.history.pushState({}, '', newUrl);
        }

        showScreen('game');
        document.getElementById('gameStatus').textContent = 'waiting for game to start...';
      });

      socket.on('player_joined', () => {
        console.log('[CLIENT] Other player joined');
        showScreen('game');
        document.getElementById('gameStatus').textContent = 'opponent joined! starting soon...';
      });

      socket.on('start_round', ({ duration, serverTime }) => {
        console.log('[CLIENT] Round starting');
        resetGameUI();
        showScreen('game');
        document.getElementById('gameStatus').textContent = 'pick one!';
        startTimer(duration, serverTime);
      });

      socket.on('player_ready', ({ player }) => {
        console.log('[CLIENT] Player', player, 'ready');
      });

      socket.on('opponent_ready', () => {
        const btn = document.getElementById('playAgainBtn');
        if (btn) btn.textContent = 'friend is ready :O';
      });

      // NEW: Simplified game_result handler - server sends from our perspective
      socket.on('game_result', ({ myChoice: serverMyChoice, theirChoice, result, myScore: serverMyScore, theirScore: serverTheirScore }) => {
        console.log('[CLIENT] Game result:', result, 'My choice:', serverMyChoice, 'Their choice:', theirChoice);
        if (timerInterval) clearInterval(timerInterval);

        // Update scores from server (authoritative)
        myScore = serverMyScore;
        theirScore = serverTheirScore;

        // Update win streak
        if (result === 'win') {
          winStreak++;
        } else {
          winStreak = 0;
        }

        updateScore();
        updateStreak();

        // Render result
        const resultDiv = document.getElementById('result');
        resultDiv.innerHTML = renderResult(serverMyChoice, theirChoice, result, myScore, theirScore, winStreak);
        resultDiv.style.display = 'block';
        document.getElementById('gameStatus').textContent = '';
      });

      // Reconnection handling - simplified
      socket.on('reconnected', (state) => {
        console.log('[CLIENT] Reconnected:', state);
        currentRoom = state.roomId;
        myPlayerIndex = state.playerIndex;
        myScore = state.myScore;
        theirScore = state.theirScore;
        winStreak = 0; // Reset streak on reconnect

        // Update URL
        const newUrl = window.location.pathname + '?room=' + state.roomId;
        window.history.pushState({}, '', newUrl);

        updateScore();
        resetGameUI();
        showScreen('game');

        if (state.playerCount === 1) {
          document.getElementById('gameStatus').textContent = 'waiting for opponent...';
        } else if (state.status === 'playing') {
          document.getElementById('gameStatus').textContent = 'pick one!';
          // Timer will be started by the start_round event that follows
        } else if (state.lastGameResult) {
          // Show last result
          const lastResult = state.lastGameResult;
          const mySlot = state.playerIndex - 1;
          const myLastChoice = lastResult.choices[mySlot];
          const theirLastChoice = lastResult.choices[mySlot === 0 ? 1 : 0];

          let resultForMe;
          if (lastResult.result === 'tie') {
            resultForMe = 'tie';
          } else if ((lastResult.result === 'player1' && mySlot === 0) || (lastResult.result === 'player2' && mySlot === 1)) {
            resultForMe = 'win';
          } else {
            resultForMe = 'lose';
          }

          const resultDiv = document.getElementById('result');
          resultDiv.innerHTML = renderResult(myLastChoice, theirLastChoice, resultForMe, myScore, theirScore, 0);
          resultDiv.style.display = 'block';
          document.getElementById('gameStatus').textContent = '';
        } else {
          document.getElementById('gameStatus').textContent = 'waiting for next round...';
        }

        showError('reconnected! :3');
      });

      socket.on('opponent_disconnected', () => {
        console.log('[CLIENT] Opponent disconnected');
        if (timerInterval) clearInterval(timerInterval);

        document.getElementById('gameStatus').textContent = 'opponent disconnected... waiting';

        const resultDiv = document.getElementById('result');
        if (resultDiv && resultDiv.style.display === 'block') {
          const playAgainBtn = resultDiv.querySelector('button');
          if (playAgainBtn) {
            playAgainBtn.textContent = 'waiting for reconnect...';
            playAgainBtn.disabled = true;
          }
        }
      });

      socket.on('player_reconnected', () => {
        console.log('[CLIENT] Opponent reconnected');
        showError('opponent reconnected! :3');

        const gameStatus = document.getElementById('gameStatus');
        if (gameStatus && gameStatus.textContent.includes('disconnected')) {
          gameStatus.textContent = 'opponent reconnected!';
        }

        const resultDiv = document.getElementById('result');
        if (resultDiv && resultDiv.style.display === 'block') {
          const playAgainBtn = resultDiv.querySelector('button');
          if (playAgainBtn) {
            playAgainBtn.textContent = 'play again? :p';
            playAgainBtn.disabled = false;
          }
        }
      });

      socket.on('player_left', () => {
        console.log('[CLIENT] Opponent left the game');
        if (timerInterval) clearInterval(timerInterval);
        showPlayerLeftDialog();
      });

      socket.on('error', (message) => {
        console.error('[CLIENT ERROR]', message);
        showError(message);
      });

      socket.on('reset_requested', () => {
        const scoreDiv = document.getElementById('score');
        scoreDiv.textContent = 'friend wants to reset! (click to agree)';
        scoreDiv.classList.add('reset-incoming');
      });

      socket.on('reset_cancelled', () => {
        const scoreDiv = document.getElementById('score');
        scoreDiv.classList.remove('pending-reset');
        scoreDiv.classList.remove('reset-incoming');
        updateScore();
      });

      socket.on('score_reset', () => {
        myScore = 0;
        theirScore = 0;
        winStreak = 0;
        const scoreDiv = document.getElementById('score');
        scoreDiv.classList.remove('pending-reset');
        scoreDiv.classList.remove('reset-incoming');
        updateScore();
        updateStreak();
      });

      socket.on('ping_response', ({ timestamp }) => {
        myPing = Date.now() - timestamp;
        if (debugMode) {
          document.getElementById('myPing').textContent = myPing;
        }
      });

      socket.on('receive_reaction', ({ emoji }) => {
        displayReaction(emoji);
      });
    }
  </script>
</body>
</html>
